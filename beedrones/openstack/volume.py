# SPDX-License-Identifier: EUPL-1.2
#
# (C) Copyright 2018-2022 CSI-Piemonte

from beecell.simple import jsonDumps

from time import sleep

import ujson as json
from six import ensure_text
from beecell.types.type_dict import dict_get
from beecell.types.type_string import truncate, bool2str
from six.moves.urllib.parse import urlencode
from beedrones.openstack.client import OpenstackClient, OpenstackError, OpenstackObject, setup_client


class OpenstackVolumeObject(OpenstackObject):
    def setup(self):
        self.uri = self.manager.endpoint('cinderv2')
        self.client = OpenstackClient(self.uri, self.manager.proxy, timeout=self.manager.timeout)


class OpenstackVolumeV3Object(OpenstackObject):
    def setup(self):
        self.uri = self.manager.endpoint('cinderv3')
        self.client = OpenstackClient(self.uri, self.manager.proxy, timeout=self.manager.timeout)
        self.set_cinder_microversion('3.50')


class OpenstackVolumeV3(OpenstackVolumeV3Object):
    """A volume is a detachable block storage device similar to a USB hard drive. You can attach a volume to one
    instance at a time. The snapshot_id and source_volid parameters specify the ID of the snapshot or volume from which
    this volume originates. If the volume was not created from a snapshot or source volume, these values are null.
    When you create, list, update, or delete volumes, the possible status values are:

    - creating: The volume is being created.
    - available: The volume is ready to attach to an instance.
    - attaching: The volume is attaching to an instance.
    - detaching: The volume is detaching from an instance.
    - in-use: The volume is attached to an instance.
    - maintenance: The volume is locked and being migrated.
    - deleting: The volume is being deleted.
    - awaiting-transfer: The volume is awaiting for transfer.
    - error: A volume creation error occurred.
    - error_deleting: A volume deletion error occurred.
    - backing-up: The volume is being backed up.
    - restoring-backup: A backup is being restored to the volume.
    - error_backing-up: A backup error occurred.
    - error_restoring: A backup restoration error occurred.
    - error_extending: An error occurred while attempting to extend a volume.
    - downloading: The volume is downloading an image.
    - uploading: The volume is being uploaded to an image.
    - retyping: The volume is changing type to another volume type.
    - extending: The volume is being extended.
    """

    def __init__(self, manager):
        OpenstackVolumeObject.__init__(self, manager)

        self.type = OpenstackVolumeTypeV3(self)
        # self.backup = OpenstackVolumeBackup(self)
        self.snapshot = OpenstackVolumeSnapshotV3(self)
        self.group = OpenstackVolumeGroupV3(self)
        # self.qos = OpenstackVolumeQos(self)
        self.attachment = OpenstackAttachmentV3(self)

    @setup_client
    def messages(self, detail=False, tenant=None, limit=None, marker=None, all_tenants=True, *args, **kvargs):
        """Lists all, shows, and deletes messages. These are error messages generated by failed operations as a way to
        find out what happened when an asynchronous operation failed.

        :param sort: Comma-separated list of sort keys and optional sort directions in the form of
            < key > [: < direction > ]. A valid direction is asc (ascending) or desc (descending). [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as
            the marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return a list of dictionaries (each one is a volume)
        """
        query = {}
        path = '/messages'
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack cinder messages: %s' % truncate(res[0]))
        return res[0]['messages']

    @setup_client
    def list(self, detail=False, tenant=None, limit=None, offset=None, marker=None, all_tenants=True, *args, **kvargs):
        """List volumes

        :param tenant: tenant id
        :param sort: Comma-separated list of sort keys and optional sort directions in the form of < key >
            [: < direction > ]. A valid direction is asc (ascending) or desc (descending).
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request.
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request.
        :param limit:  Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request.
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and
            use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return a list of dictionaries (each one is a volume)
        """
        path = '/volumes'
        if detail is True:
            path = '/volumes/detail'

        query = kvargs
        query['with_count'] = True
        if tenant is not None:
            query['tenant_id'] = tenant
        if limit is not None:
            query['limit'] = limit
        if offset is not None:
            query['offset'] = offset
        if marker is not None:
            query['marker'] = marker
        if all_tenants is True:
            query['all_tenants'] = 1

        path = '%s?%s' % (path, urlencode(query))

        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volumes: %s' % truncate(res[0]))
        self.volume_count = res[0]['count']
        volumes = res[0].pop('volumes')
        return volumes

    def list_all(self, detail=False, limit=1000):
        """List all volumes without limits

        :raises OpenstackError: raise :class:`.OpenstackError`
        :return a list of dictionaries (each one is a volume)
        """
        volumes = self.list(detail=detail, limit=limit, offset=0)
        offset = limit
        while len(volumes) < self.volume_count:
            volumes.extend(self.list(detail=detail, limit=limit, offset=offset))
            offset += limit
        return volumes

    @setup_client
    def get(self, oid=None, name=None):
        """
        :param oid: volume id
        :param name: volume name
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        if oid is not None:
            path = '/volumes/%s' % oid
        elif name is not None:
            path = '/volumes/detail?name=%s' % name
        else:
            raise OpenstackError('Specify at least volume id or name')
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volume: %s' % truncate(res[0]))
        if oid is not None:
            volume = res[0]['volume']
        elif name is not None:
            volume = res[0]['volumes'][0]

        return volume

    @setup_client
    def create(self, *args, **kvargs):
        """Creates a volume. To create a bootable volume, include the UUID of the image from which you want to create
        the volume in the imageRef attribute in the request body.

        Preconditions:
            You must have enough volume storage quota remaining to create a volume of size requested.

        Asynchronous Postconditions:
            With correct permissions, you can see the volume status as available through API calls.
            With correct access, you can see the created volume in the storage system that OpenStack Block Storage
            manages.

        Troubleshooting:
            If volume status remains creating or shows another error status, the request failed. Ensure you meet the
            preconditions then investigate the storage back end.
            Volume is not created in the storage system that OpenStack Block Storage manages.
            The storage node needs enough free storage space to match the size of the volume creation request.

        :param size: The size of the volume, in gibibytes (GiB).
        :param description: The volume description.
        :param project_id: The UUID of the tenant in a multi-tenancy cloud.
        :param name: The volume name. [optional]
        :param availability_zone: The availability zone. [optional]
        :param source_volid: The UUID of the source volume. The API creates a new volume with the same size as the
            source volume. [optional]
        :param multiattach: To enable this volume to attach to more than one server, set this value to true. Default
            is false. [optional]
        :param snapshot_id: To create a volume from an existing snapshot, specify the UUID of the volume snapshot. The
            volume is created in same availability zone and with same size as the snapshot. [optional]
        :param imageRef: The UUID of the image from which you want to create the volume. Required to create a bootable
            volume. [optional]
        :param volume_type: The volume type. To create an environment with multiple-storage back ends, you must specify
            a volume type. Block Storage volume back ends are spawned as children to cinder-volume, and they are keyed
            from a unique queue. They are named cinder- volume.HOST.BACKEND. For example,
            cinder-volume.ubuntu.lvmdriver. When a volume is created, the scheduler chooses an appropriate back end to
            handle the request based on the volume type. Default is None. For information about how to use volume types
            to create multiple-storage back ends, see Configure multiple-storage back ends. [optional]
        :param metadata: One or more metadata key and value pairs that are associated with the volume. [optional]
        :param source_replica: The UUID of the primary volume to clone. [optional]
        :param consistencygroup_id: The UUID of the consistency group. [optional]
        :param scheduler_hints: The dictionary of data to send to the scheduler. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = kvargs
        path = '/volumes'
        res = self.client.call(path, 'POST', data=jsonDumps({'volume': data}), token=self.manager.identity.token, timeout=240)
        self.logger.debug('Create openstack volume: %s' % truncate(res[0]))
        return res[0]['volume']

    @setup_client
    def clone(self, name, volume_id, project_id, volume_type=None, *args, **kvargs):
        """Clone a volume.

        :param project_id: the id of the parent project
        :param name: The volume name
        :param volume_id: id of the volume to clone
        :param volume_type: The volume type. To create an environment with multiple-storage back ends, you must specify
            a volume type. Block Storage volume back ends are spawned as children to cinder-volume, and they are keyed
            from a unique queue. They are named cinder- volume.HOST.BACKEND. For example,
            cinder-volume.ubuntu.lvmdriver. When a volume is created, the scheduler chooses an appropriate back end to
            handle the request based on the volume type. Default is None. For information about how to use volume types
            to create multiple-storage back ends, see Configure multiple-storage back ends. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        token = self.manager.identity.token
        # create snapshot
        data = {
            'name': 'snapshot-clone-%s' % volume_id,
            'volume_id': volume_id,
            'force': True
        }
        res = self.client.call('/snapshots', 'POST', data=jsonDumps({'snapshot': data}), token=token)
        snapshot_id = res[0]['snapshot']['id']
        self.logger.debug('Create openstack snapshot: %s' % snapshot_id)

        # wait for snapshot
        cond = True
        while cond is True:
            res = self.client.call('/snapshots/%s' % snapshot_id, 'GET', data='', token=token)
            status = res[0]['snapshot']['status']
            if status == 'available':
                cond = False
            sleep(2)

        # create volume
        data = {
            'name': name,
            'project_id': project_id,
            'snapshot_id': snapshot_id,
        }
        if volume_type is not None:
            data['volume_type'] = volume_type
        res = self.client.call('/volumes', 'POST', data=jsonDumps({'volume': data}), token=token)
        volume = res[0]['volume']
        self.logger.debug('Create openstack volume: %s' % truncate(volume))

        # wait for volume
        cond = True
        while cond is True:
            res = self.client.call('/volumes/%s' % volume['id'], 'GET', data='', token=token)
            status = res[0]['volume']['status']
            if status == 'available' or status == 'error':
                cond = False
            sleep(2)

        # delete snapshot
        self.client.call('/snapshots/%s' % snapshot_id, 'DELETE', data='', token=token)
        while True:
            try:
                self.client.call('/snapshots/%s' % snapshot_id, 'GET', data='', token=token)
                sleep(2)
            except:
                self.logger.debug('Delete openstack snapshot: %s' % snapshot_id)
                break

        # wait for volume
        cond = True
        while cond is True:
            res = self.client.call('/volumes/%s' % volume['id'], 'GET', data='', token=token)
            status = res[0]['volume']['status']
            if status == 'available' or status == 'error':
                cond = False
            sleep(2)
        return volume

    @setup_client
    def update(self, volume_id, *args, **kvargs):
        """Updates a volume.

        :param volume_id: The UUID of the volume.
        :param description: The volume description. [optional]
        :param project_id: The UUID of the project in a multi-tenancy cloud. [optional]
        :param name: The volume name. [optional]
        :param metadata: One or more metadata key and value pairs that are associated with the volume. [optional]
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/volumes/%s' % volume_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'volume': data}), token=self.manager.identity.token)
        self.logger.debug('Update openstack volume: %s' % truncate(res[0]))
        return res[0]['volume']

    @setup_client
    def delete(self, volume_id, force=False):
        """Delete a volume.

        :param volume_id: The UUID of the volume.
        :param force: force delete [deafault=Fasle]
        :return: None
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        if force is False:
            path = '/volumes/%s' % volume_id
            res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        else:
            path = '/volumes/%s/action' % volume_id
            data = {'os-force_delete': {}}
            res = self.client.call(path, 'POST', data=data, token=self.manager.identity.token)
        self.logger.debug('Delete openstack volume: %s' % truncate(res[0]))
        return res[0]

    @setup_client
    def get_metadata(self, volume_id, key=None):
        """Shows metadata for a volume.

        :param volume_id: The UUID of the volume.
        :return: list of metadata
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/volumes/%s/metadata' % volume_id
        if key is not None:
            path += '/' + key

        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        resp = ensure_text(res[0])
        resp = json.loads(resp)
        self.logger.debug('Get openstack metadata: %s' % truncate(resp))
        return resp

    @setup_client
    def add_metadata(self, volume_id, metadata):
        """Creates or replaces metadata for a volume. Does not modify items that are not in the request.

        :param volume_id: The UUID of the volume.
        :param metadata: One or more metadata key and value pairs that are associated with the volume.
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/volumes/%s/metadata' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps({'metadata': metadata}),
                               token=self.manager.identity.token)
        self.logger.debug('Add openstack volume %s metadata %s' % (volume_id, metadata))
        return res[0]['metadata']

    @setup_client
    def remove_metadata(self, volume_id, key):
        """Deletes metadata for a volume.

        :param volume_id: The UUID of the volume.
        :param key: The metadata key name for the metadata that you want to remove.
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/volumes/%s/metadata/%s' % (volume_id, key)
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack volume %s metadata key %s' % (volume_id, key))
        return True

    #
    # backend, hosts
    #
    @setup_client
    def get_backend_storage_pools(self, detail=True, hostname=None, backend_name=None):
        """Lists all back-end storage pools that are known to the scheduler service.

        :param detail: Indicates whether to show pool details or only pool names in the response. Set to true to show
            pool details. Set to false to show only pool names. Default is false.
        :param hostname: storage pool hostname [optional]
        :param backend_name: volume backend name [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: dict
        """
        path = '/scheduler-stats/get_pools?detail=%s' % bool2str(detail)
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        pools = res[0]['pools']
        if hostname is not None:
            hostname = hostname.split('#')[1]
            pools = [v for v in pools if v['name'].find(hostname) >= 0]
        if backend_name is not None:
            pools = [v for v in pools if dict_get(v, 'capabilities.volume_backend_name') == backend_name]
        self.logger.debug('Show openstack volume backend storage pools %s' % pools)
        return pools

    @setup_client
    def get_backend_capabilities(self, hostname):
        """Shows capabilities for a storage back end on the host. The hostname takes the form of
        hostname@volume_backend_name.

        :param hostname: The name of the host that hosts the storage back end.
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/capabilities/%s' % hostname
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Show openstack volume backend capabilities %s' % truncate(res[0]))
        return res[0]

    @setup_client
    def list_hosts(self):
        """Lists all hosts summary info that is not disabled.

        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            [
                {
                    "service-status": "available",
                    "service": "cinder-backup",
                    "zone": "nova",
                    "service-state": "enabled",
                    "host_name": "node1",
                    "last-update": "2017-03-09T21:38:41.000000"
                },..
            ]
        """
        path = '/os-hosts'
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('List openstack volume hosts summary info %s' % truncate(res[0]))
        return res[0]['hosts']

    #
    # actions
    #
    @setup_client
    def extend(self, volume_id, new_size):
        """Extends the size of a volume to a requested size, in gibibytes (GiB).

        Preconditions:
            Volume status must be available.
            Sufficient amount of storage must exist to extend the volume.
            The user quota must have sufficient volume storage.

        Troubleshooting:

            An error_extending volume status indicates that the request failed. Ensure that you meet the preconditions
            and retry the request. If the request fails again, investigate the storage back end.

        :param volume_id: The UUID of the volume.
        :param new_size: The new size of the volume, in gibibytes (GiB).
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-extend': {
                'new_size': new_size
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Extend openstack volume %s size to %s' % (volume_id, new_size))
        return True

    @setup_client
    def reset_status(self, volume_id, status, attach_status, migration_status):
        """Administrator only. Resets the status, attach status, and migration status for a volume.

        :param volume_id: The UUID of the volume.
        :param status: The volume status.
        :param migration_status: The volume migration status.
        :param attach_status: The volume attach status. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-reset_status': {
                'status': status,
                'attach_status': attach_status,
                'migration_status': migration_status
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Reset openstack volume %s status' % volume_id)
        return True

    @setup_client
    def set_image_metadata(self, volume_id, metadata):
        """Sets the image metadata for a volume.

        :param volume_id: The UUID of the volume.
        :param metadata: One or more metadata key and value pairs for the snapshot, if any.

            "metadata": {
                "image_id": "521752a6-acf6-4b2d-bc7a-119f9148cd8c",
                "image_name": "image",
                "kernel_id": "155d900f-4e14-4e4c-a73d-069cbf4541e6",
                "ramdisk_id": "somedisk"
            }

        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-set_image_metadata': {
                'metadata': metadata
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Set openstack volume %s image metadata' % volume_id)
        return True

    @setup_client
    def remove_image_metadata(self, volume_id, key):
        """Removes image metadata, by key, from a volume.

        :param volume_id: The UUID of the volume.
        :param key: The metadata key name for the metadata that you want to remove.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-unset_image_metadata': {
                'key': key
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Uset openstack volume %s image metadata key' % volume_id)
        return True

    @setup_client
    def show_image_metadata(self, volume_id):
        """Shows image metadata for a volume.

        :param volume_id: The UUID of the volume.
        :param key: The metadata key name for the metadata that you want to remove.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            {
                "metadata": {
                    "key1": "value1",
                    "key2": "value2"
                }
            }
        """
        data = {
            'os-show_image_metadata': {}
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Show openstack volume %s image metadata' % volume_id)
        return res[0].get('metadata', {})

    @setup_client
    def attach_volume_to_server(self, volume_id, server_id, mountpoint):
        """Attaches a volume to a server.

        Preconditions:
            Volume status must be available.
            You should set instance_uuid or host_name.

        :param volume_id: The UUID of the volume.
        :param server_id : The UUID of the attaching instance.
        :param mountpoint: The attaching mount point. Ex: /dev/vdc
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-attach': {
                'instance_uuid': server_id,
                'mountpoint': mountpoint
            }
        }
        path = '/volumes/%s/action' % volume_id
        self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Attach openstack volume %s to server %s' % (volume_id, server_id))
        return True

    @setup_client
    def detach_volume_from_server(self, volume_id, attachment_id, force=False, connector=None):
        """Detaches a volume from a server or forces a volume to detach.
        If force is True Rolls back an unsuccessful detach operation after you disconnect the volume.

        Preconditions:
            Volume status must be in-use.

        :param volume_id: The UUID of the volume.
        :param attachment_id : The interface ID.
        :param force: if True force detach
        :param connector: The connector object. "connector": {"initiator": "iqn.2012-07.org.fake:01"}
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-detach': {
                'attachment_id': attachment_id
            }
        }
        if force is True:
            data = {
                'os-force_detach': {
                    'attachment_id': attachment_id,
                    'connector': connector
                }
            }
        path = '/volumes/%s/action' % volume_id
        self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Detach openstack volume %s' % volume_id)
        return True

    @setup_client
    def unmanage(self, volume_id):
        """Removes a volume from Block Storage management without removing the back-end storage object that is
        associated with it.

        Preconditions:
            Volume status must be available.

        :param volume_id: The UUID of the volume.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-unmanage': {}
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Unmanage openstack volume %s' % volume_id)
        return True

    @setup_client
    def manage(self, source_volume_id, name, volume_type, bootable=True, desc=None,
               availability_zone='nova', host=None, cluster=None):
        """Creates a Block Storage volume by using existing storage rather than allocating new storage.
        The caller must specify a reference to an existing storage volume in the ref parameter in the request. Although
        each storage driver might interpret this reference differently, the driver should accept a reference structure
        that contains either a source-id or source-name element, if possible.
        The API chooses the size of the volume by rounding up the size of the existing storage volume to the next
        gibibyte (GiB).

        :param source_volume_name: The id of the source volume.
        :param name: The name of the new volume
        :param desc: The description of the new volume
        :param availability_zone: The availability zone [default=nova]
        :param volume_type: The UUID of the volume_type
        :param bootable: The bootable value [default=True]
        :param host: the OpenStack Block Storage host where the existing resource resides [optional]
        :param cluster: the OpenStack Block Storage cluster where the resource resides [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        source_volume_name = 'volume-%s' % source_volume_id
        if host is not None:
            storage_pool = host.split('#')[1]
            source_volume_name = '%s/%s' % (storage_pool, source_volume_name)

        data = {
            'ref': {
                'source-name': source_volume_name,
            },
            'name': name,
            'availability_zone': availability_zone,
            'description': desc,
            'volume_type': volume_type,
            'bootable': bootable,
            'metadata': None
        }
        if host is not None:
            data['host'] = host
        if cluster is not None:
            data['host'] = None
            data['cluster'] = cluster
        path = '/manageable_volumes'
        res = self.client.call(path, 'POST', data=jsonDumps({'volume': data}), token=self.manager.identity.token)
        self.logger.debug('manage openstack volume %s: %s' % (source_volume_name, truncate(res)))
        return res[0]['volume']

    @setup_client
    def manageable_volumes(self, host, sort=None, offset=None, limit=None, marker=None):
        """Search a volume backend and list detail of volumes which are available to manage.

        :param sort: (Optional) Comma-separated list of sort keys and optional sort directions in the form of < key >
            [: < direction > ]. A valid direction is asc (ascending) or desc (descending).
        :param offset: (Optional) Used in conjunction with limit to return a slice of items. offset is where to start
            in the list.
        :param limit: (Optional) Requests a page size of items. Returns a number of items up to a limit value. Use the
            limit parameter to make an initial limited request and use the ID of the last-seen item from the response
            as the marker parameter value in a subsequent limited request.
        :param marker: (Optional) The ID of the last-seen item. Use the limit parameter to make an initial limited
            request and use the ID of the last-seen item from the response as the marker parameter value in a
            subsequent limited request.
        :param host: Filter the service list result by host name of the service.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: list of volume
        """
        query = {'host': host}
        if limit is not None:
            query['limit'] = limit
        if offset is not None:
            query['offset'] = offset
        if marker is not None:
            query['marker'] = marker
        if sort is not None:
            query['sort'] = sort

        # self.set_cinder_microversion('3.8')
        path = '/manageable_volumes/detail'
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', token=self.manager.identity.token)
        self.logger.debug('list openstack volume which are available to manage: %s' % truncate(res))
        return res[0]['manageable-volumes']

    @setup_client
    def migrate(self, volume_id, host, force_host_copy=False, lock_volume=None):
        """Migrates a volume to the specified host. It is generally not recommended to migrate an in-use multiattach
        volume if that volume has more than one active read/write attachment.

        Policy defaults enable only users with the administrative role to perform this operation. Cloud providers can
        change these permissions through the policy.json file.

        Preconditions:
            The volume status must be available or in-use.
            The volume migration_status must be None, deleting, error, or success.
            The volume replication_status must be None, disabled or not-capable.
            The migration must happen to another host from which the volume currently resides.
            The volume must not be a member of a group.
            The volume must not have snapshots.

        Asynchronous Postconditions:
            On success, the volume status will return to its original status of available or in-use and the
            migration_status will be success. On failure, the migration_status will be error. In the case of failure,
            if lock_volume was true and the volume was originally available when it was migrated, the status will go
            back to available.

        :param volume_id: The UUID of the volume.
        :param host: The target host for the volume migration. Host format is host@backend.
        :param force_host_copy: If false (the default), rely on the volume backend driver to perform the migration,
            which might be optimized. If true, or the volume driver fails to migrate the volume itself, a generic
            host-based migration is performed.
        :param lock_volume : If true, migrating an available volume will change its status to maintenance preventing
            other operations from being performed on the volume such as attach, detach, retype, etc. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-migrate_volume': {
                'host': host,
                'force_host_copy': force_host_copy,
            }
        }
        if lock_volume is not None:
            data['os-migrate_volume']['lock_volume'] = lock_volume
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Migrates openstack volume %s' % volume_id)
        return True

    @setup_client
    def force_delete(self, volume_id):
        """Attempts force-delete of volume, regardless of state.

        :param volume_id: The UUID of the volume.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-force_delete': {}
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Force delete openstack volume %s' % volume_id)
        return True

    @setup_client
    def update_bootable_status(self, volume_id, bootable=False):
        """Update the bootable status for a volume, mark it as a bootable volume.

        :param volume_id: The UUID of the volume.
        :param bootable: bootable
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-set_bootable': {
                'bootable': bootable
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Update bootable status of openstack volume %s' % volume_id)
        return True

    @setup_client
    def change_type(self, volume_id, new_type, policy='on-demand'):
        """Change the volume type of existing volume. Cinder may migrate the volume to proper volume host according
        to the new volume type.
        Retyping an in-use volume from a multiattach-capable type to a non-multiattach-capable type, or vice-versa,
        is not supported. It is generally not recommended to retype an in-use multiattach volume if that volume has
        more than one active read/write attachment.

        :param volume_id: The UUID of the volume.
        :param new_type: The new volume type that volume is changed with.
        :param policy: migration policy. Can be on-demand or never [default=on-demand]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-retype': {
                'new_type': new_type,
                'migration_policy': policy
            }
        }
        path = '/volumes/%s/action' % volume_id
        self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Change type of openstack volume %s' % volume_id)
        return True

    @setup_client
    def upload_to_image(self, volume_id, image_name, disk_format='qcow2', container_format='bare'):
        """Uploads the specified volume to image service.

        :param volume_id: The UUID of the volume.
        :param image_name: image name
        :param disk_format: disk format [default=qcow2]
        :param container_format: container format [default=bare]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: image id
        """
        data = {
            'os-volume_upload_image': {
                'image_name': image_name,
                'force': False,
                'disk_format': disk_format,
                'container_format': container_format,
                'visibility': 'private',
                'protected': False
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Upload openstack volume %s to image service' % volume_id)
        return res[0]['os-volume_upload_image']['image_id']


class OpenstackVolumeTypeV3(OpenstackVolumeV3Object):
    """
    todo: volume type encryption, Private volume type access to project.
    """

    def __init__(self, volume):
        OpenstackVolumeObject.__init__(self, volume.manager)

    @setup_client
    def list(self, *args, **kvargs):
        """Lists volume types.

        :param sort_key: Sorts by an attribute. A valid value is name, status, container_format, disk_format, size, id,
            created_at, or updated_at. Default is created_at. The API uses the natural sorting direction of the sort_key
            attribute value. [optional]
        :param sort_dir: Sorts by one or more sets of attribute and sort direction combinations. If you omit the sort
            direction in a set, default is desc. [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :param backend_name: name of the volume storage backend [optional]
        :return a list of dictionaries (each one is a volume type):
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/types'
        query = kvargs
        backend_name = query.pop('backend_name', None)
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        volume_types = res[0]['volume_types']
        if backend_name is not None:
            volume_types = [v for v in volume_types if dict_get(v, 'extra_specs.volume_backend_name') == backend_name]
        self.logger.debug('Get openstack volume types: %s' % volume_types)
        return volume_types

    @setup_client
    def get(self, volume_type_id):
        """Shows details for a volume type.

        :param volume_type_id: volume id
        :param name: volume name
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/types/%s' % volume_type_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volume type: %s' % truncate(res[0]))
        return res[0]['volume_type']

    @setup_client
    def create(self, name, desc, is_public=True, extra_spec={}):
        """Creates a volume type. To create an environment with multiple-storage back ends, you must specify a volume
        type. Block Storage volume back ends are spawned as children to cinder-volume, and they are keyed from a unique
        queue. They are named cinder-volume.HOST.BACKEND. For example, cinder-volume.ubuntu.lvmdriver. When a volume is
        created, the scheduler chooses an appropriate back end to handle the request based on the volume type.

        For information about how to use volume types to create multiple- storage back ends, see
        https://docs.openstack.org/cinder/latest/admin/blockstorage-multi-backend.html.

        :param name: The volume type name.
        :param desc: The volume description. [optional]
        :param is_public:
        :param extra_specs:
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = {
            'name': name,
            'description': desc,
            'os-volume-type-access:is_public': True,
            'extra_specs': extra_spec
        }
        path = '/types'
        res = self.client.call(path, 'POST', data=jsonDumps({'volume_type': data}),
                               token=self.manager.identity.token)
        self.logger.debug('Create openstack volume type: %s' % truncate(res[0]))
        return res[0]['volume_type']

    @setup_client
    def update(self, volume_type_id, *args, **kvargs):
        """Updates a volume type.

        :param volume_type_id: The UUID of the volume type.
        :param name: The volume type name.
        :param desc: The volume description. [optional]
        :param is_public:
        :param extra_specs:
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/volumes/%s' % volume_type_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'volume_type': data}), token=self.manager.identity.token)
        self.logger.debug('Update openstack volume: %s' % truncate(res[0]))
        return res[0]['volume']

    @setup_client
    def delete(self, volume_type_id):
        """Delete a volume type.

        :param volume_type_id: The UUID of the volume type.
        :return: None
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/types/%s' % volume_type_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack volume type: %s' % truncate(res[0]))
        return res[0]


class OpenstackVolumeSnapshotV3(OpenstackVolumeV3Object):
    """A snapshot is a point-in-time copy of the data that a volume contains.
    When you create, list, or delete snapshots, these status values are possible:

    - creating: The snapshot is being created.
    - available: The snapshot is ready to use.
    - backing-up: The snapshot is being backed up.
    - deleting: The snapshot is being deleted.
    - error: A snapshot creation error occurred.
    - deleted: The snapshot has been deleted.
    - unmanaging: The snapshot is being unmanaged.
    - restoring: The snapshot is being restored to a volume.
    - error_deleting: A snapshot deletion error occurred.
    """

    def __init__(self, volume):
        OpenstackVolumeV3Object.__init__(self, volume.manager)

    @setup_client
    def _list(self, *args, **kvargs):
        """Lists all Block Storage snapshots, with details, that the project can access.

        :param detail: if True show details
        :param volume_id: uuid of the volume
        :param group_snapshot_id: uuid of the volume group snapshot
        :param sort_key: Sorts by an attribute. A valid value is name, status, container_format, disk_format, size, id,
            created_at, or updated_at. Default is created_at. The API uses the natural sorting direction of the sort_key
            attribute value. [optional]
        :param sort_dir: Sorts by one or more sets of attribute and sort direction combinations. If you omit the sort
            direction in a set, default is desc. [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:
        """
        path = '/snapshots/detail'
        query = kvargs
        query['all_tenants'] = True
        query['with_count'] = True

        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        total = res[0]['count']
        res = res[0]['snapshots']
        return res, total

    def _list_all(self, limit=1000):
        """List all volumes without limits

        :raises OpenstackError: raise :class:`.OpenstackError`
        :return a list of dictionaries (each one is a volume)
        """
        snapshots, total = self._list(limit=limit, offset=0)
        offset = limit
        while len(snapshots) < total:
            new_snapshots, new_total = self._list(limit=limit, offset=offset)
            snapshots.extend(new_snapshots)
            offset += limit
        return snapshots

    def list(self, all=True, *args, **kvargs):
        """Lists all Block Storage snapshots, with details, that the project can access.

        :param detail: if True show details
        :param volume_id: uuid of the volume
        :param group_snapshot_id: uuid of the volume group snapshot
        :param sort_key: Sorts by an attribute. A valid value is name, status, container_format, disk_format, size, id,
            created_at, or updated_at. Default is created_at. The API uses the natural sorting direction of the sort_key
            attribute value. [optional]
        :param sort_dir: Sorts by one or more sets of attribute and sort direction combinations. If you omit the sort
            direction in a set, default is desc. [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :param all: if True return all the snaphots, otherwise return the first 1000. [default=True]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:
        """
        if all is True:
            res = self._list_all()
        else:
            res = self._list(*args, **kvargs)

        volume_id = kvargs.pop('volume_id', None)
        if volume_id is not None:
            resp = [s for s in res if s.get('volume_id') == volume_id]
        else:
            resp = res
        self.logger.debug('Get openstack snapshots: %s' % truncate(resp))
        return resp

    @setup_client
    def get(self, snapshot_id):
        """Shows details for a snapshot.

        :param snapshot_id: snapshot id
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            {
                "status": "available",
                "os-extended-snapshot-attributes:progress": "100%",
                "description": "Daily backup",
                "created_at": "2013-02-25T04:13:17.000000",
                "metadata": {},
                "volume_id": "5aa119a8-d25b-45a7-8d1b-88e127885635",
                "os-extended-snapshot-attributes:project_id": "0c2eba2c5af04d3f9e9d0d410b371fde",
                "size": 1,
                "id": "2bb856e1-b3d8-4432-a858-09e4ce939389",
                "name": "snap-001",
                "updated_at": "2013-03-11T07:24:57Z"
            }
        """
        path = '/snapshots/%s' % snapshot_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack snapshot: %s' % truncate(res[0]))
        return res[0]['snapshot']

    @setup_client
    def create(self, name, force=False, *args, **kvargs):
        """Creates a volume snapshot, which is a point-in-time, complete copy of a volume. You can create a volume from
        a snapshot.

        :param name: The snapshot name.
        :param description: The snapshot description.
        :param volume_id: The UUID of the volume.
        :param force: Indicates whether to snapshot, even if the volume is attached. [default=False]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = kvargs
        data['name'] = name
        data['force'] = force
        path = '/snapshots'
        res = self.client.call(path, 'POST', data=jsonDumps({'snapshot': data}), token=self.manager.identity.token)
        self.logger.debug('Create openstack snapshot: %s' % truncate(res[0]))
        return res[0]['snapshot']

    @setup_client
    def update(self, snapshot_id, *args, **kvargs):
        """Updates a snapshot.

        :param name: The name of the Volume Transfer.
        :param description: The snapshot description. [optional]
        :return: snapshot dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/snapshots/%s/update' % snapshot_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'snapshot': data}),
                               token=self.manager.identity.token)
        self.logger.debug('Update openstack snapshot: %s' % truncate(res[0]))
        return res[0]['snapshot']

    @setup_client
    def delete(self, snapshot_id):
        """Delete a snapshot.

        :param snapshot_id: The UUID of the snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        path = '/snapshots/%s' % snapshot_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack snapshot: %s' % truncate(res[0]))
        return True

    #
    # action
    #
    @setup_client
    def reset_status(self, snapshot_id, status):
        """Resets the status.

        :param snapshot_id: The snapshots name.
        :param status:The status for the snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-reset_status': {
                'status': status
            }
        }
        path = '/snapshots/%s/action' % snapshot_id
        res = self.client.call(path, 'POST', data=data, token=self.manager.identity.token)
        self.logger.debug('Reset openstack snapshot status: %s' % truncate(res[0]))
        return True

    @setup_client
    def revert_to(self, volume_id, snapshot_id):
        """Revert volume to snapshot

        :param volume_id: The snapshots name.
        :param snapshot_id: The snapshots name.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'revert': {
                'snapshot_id': snapshot_id
            }
        }
        path = '/volumes/%s/action' % volume_id
        self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Revert openstack volume %s to snapshot %s' % (volume_id, snapshot_id))
        return True

    #
    # metadata
    #
    @setup_client
    def get_metadata(self, snapshot_id):
        """Shows metadata for a snapshot.

        :param snapshot_id: The UUID of the snapshot.
        :return: list of metadata
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/snapshots/%s/metadata' % snapshot_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volume snapshot metadata: %s' % truncate(res[0]))
        return res[0]['metadata']

    @setup_client
    def add_metadata(self, snapshot_id, metadata):
        """Updates metadata for a snapshot. Creates or replaces metadata items that match keys. Does not modify items
        that are not in the request.

        :param snapshot_id: The UUID of the snapshot.
        :param metadata: One or more metadata key and value pairs that are associated with the volume snapshot.
        :return: list of metadata
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/snapshots/%s/metadata' % snapshot_id
        res = self.client.call(path, 'POST', data=jsonDumps({'metadata': metadata}),
                               token=self.manager.identity.token)
        self.logger.debug('Add openstack volume snapshot %s metadata %s' % truncate(res[0]))
        return res[0]['metadata']

    @setup_client
    def remove_metadata(self, snapshot_id, metadata):
        """Replaces all the snapshot's metadata with the key-value pairs in the request.

        :param snapshot_id: The UUID of the snapshot.
        :param metadata: One or more metadata key and value pairs for the snapshot, if any.
        :return: True
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/snapshots/%s/metadata' % snapshot_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'metadata': metadata}),
                               token=self.manager.identity.token)
        self.logger.debug('Update openstack volume snapshot %s metadata %s' % truncate(res[0]))
        return True


class OpenstackVolumeGroupV3(OpenstackVolumeV3Object):
    """Generic volume groups enable you to create a group of volumes and manage them together.
    How is generic volume groups different from consistency groups? Currently consistency groups in cinder only support
    consistent group snapshot. It cannot be extended easily to serve other purposes. A project may want to put volumes
    used in the same application together in a group so that it is easier to manage them together, and this group of
    volumes may or may not support consistent group snapshot. Generic volume group is introduced to solve this problem.
    By decoupling the tight relationship between the group construct and the consistency concept, generic volume groups
    can be extended to support other features in the future.
    """
    def __init__(self, volume):
        OpenstackVolumeV3Object.__init__(self, volume.manager)

    @setup_client
    def list(self, *args, **kvargs):
        """Lists volume groups.

        :param detail: if true show detail [default=False]
        :param sort: Comma-separated list of sort keys and optional sort directions in the form of
            < key > [: < direction > ]. A valid direction is asc (ascending) or desc (descending). [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as
            the marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: list of dict
        """
        path = '/groups'
        if kvargs.pop('detail', False) is True:
            path = '/groups/detail'
        query = kvargs
        query['all_tenants'] = True
        query['list_volume'] = True
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack groups: %s' % truncate(res[0]))
        return res[0]['groups']

    @setup_client
    def get(self, group_id):
        """Shows details for a group.

        :param group_id: volume group id
        :param name: qos-spec name
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: dict
        """
        path = '/groups/%s?list_volume=true' % group_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack group: %s' % truncate(res[0]))
        return res[0]['group']

    @setup_client
    def create(self, name, *args, **kvargs):
        """Creates a volume group.

        :param name: The volume group name.
        :param description: The volume group description.
        :param availability_zone: The name of the availability zone. [optional]
        :param group_type: The group type ID.
        :param volume_types: The list of volume types. In an environment with multiple-storage back ends, the scheduler
            determines where to send the volume based on the volume type. For information about how to use volume types
            to create multiple- storage back ends, see Configure multiple-storage back ends.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = kvargs
        data['name'] = name
        path = '/groups'
        res = self.client.call(path, 'POST', data=jsonDumps({'group': data}), token=self.manager.identity.token)
        self.logger.debug('Create openstack group: %s' % truncate(res[0]))
        return res[0]['group']

    @setup_client
    def create_from_source(self, name, *args, **kvargs):
        """Creates a volume group from source.

        :param name: The name of the Volume group.
        :param description: The volume group description. [optional]
        :param group_snapshot_id: The ID of the group snapshot.
        :param source_group_id: The UUID of the source group.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = kvargs
        data['name'] = name
        path = '/groups'
        res = self.client.call(path, 'POST', data=jsonDumps({'create-from-src': data}), token=self.manager.identity.token)
        self.logger.debug('Create openstack group: %s' % truncate(res[0]))
        return res[0]['group']

    @setup_client
    def update(self, group_id, *args, **kvargs):
        """Updates a volume group

        :param name: The name of the Volume group.
        :param description: The volume group description. [optional]
        :param remove_volumes: One or more volume UUIDs, separated by commas, to remove from the volume consistency
            group. [optional]
        :param add_volumes: One or more volume UUIDs, separated by commas, to add to the volume volume group.
            [optional]
        :return: qos-spec dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/groups/%s' % group_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'group': data}), token=self.manager.identity.token)
        self.logger.debug('Update openstack group: %s' % truncate(res[0]))
        return True

    @setup_client
    def delete(self, group_id, delete_volumes=False):
        """Delete a volume group.

        :param group_id: The UUID of the volume group.
        :param delete_volumes: If set to true, allows deletion of a group as well as all volumes in the group.
            [default=False]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = {
            'delete': {
                'delete-volumes': delete_volumes
            }
        }
        path = '/groups/%s/action' % group_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Delete openstack group: %s' % truncate(res[0]))
        return True

    @setup_client
    def reset_status(self, group_id, status='available'):
        """Delete a volume group.

        :param group_id: The UUID of the volume group.
        :param status: The status of the consistency group snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = {
            'reset_status': {
                'status': status
            }
        }
        path = '/groups/%s/action' % group_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Delete openstack group: %s' % truncate(res[0]))
        return True

    #
    # Group type specs
    #

    #
    # Group type
    #
    @setup_client
    def list_types(self, *args, **kvargs):
        """Lists all volume group types.

        :param detail: if true show detail [default=False]
        :param sort: Comma-separated list of sort keys and optional sort directions in the form of
            < key > [: < direction > ]. A valid direction is asc (ascending) or desc (descending). [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as
            the marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: list of dict
        """
        path = '/group_types'
        query = kvargs
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack group types: %s' % truncate(res[0]))
        return res[0]['group_types']

    @setup_client
    def get_type(self, type_id):
        """Shows details for a group type.

        :param type_id: volume group type id
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: dict
        """
        path = '/group_types/%s' % type_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack group type: %s' % truncate(res[0]))
        return res[0]['group_type']

    @setup_client
    def type_create(self, name, *args, **kvargs):
        """Creates a volume group type.

        :param name: The volume group type name.
        :param description: The volume group type description. [optional]
        :param is_public: Whether the group type is publicly visible. [default=True]
        :param group_specs: A set of key and value pairs that contains the specifications for a group type. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = kvargs
        data['name'] = name
        data['is_public'] = kvargs.get('is_public', True)
        path = '/group_types'
        res = self.client.call(path, 'POST', data=jsonDumps({'group_type': data}), token=self.manager.identity.token)
        self.logger.debug('Create openstack group type: %s' % truncate(res[0]))
        return res[0]['group_type']

    @setup_client
    def type_update(self, type_id, *args, **kvargs):
        """Updates a volume group type

        :param name: The name of the Volume group type
        :param description: The volume group description. [optional]
        :param is_public: Whether the group type is publicly visible. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/group_types/%s' % type_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'group_type': data}),
                               token=self.manager.identity.token)
        self.logger.debug('Update openstack group: %s' % truncate(res[0]))
        return res[0]['qos-spec']

    @setup_client
    def type_delete(self, type_id):
        """Delete a volume group type

        :param type_id: The UUID of the volume group type
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        path = '/group_types/%s' % type_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack group type: %s' % truncate(res[0]))
        return True

    #
    # Group snapshot
    #
    @setup_client
    def list_snapshots(self, *args, **kvargs):
        """Lists all volume group snapshots.

        :param detail: if True show details
        :param kvargs.group_id: volume group id
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:
        """
        path = '/group_snapshots'
        if kvargs.pop('detail', False) is True:
            path = '/group_snapshots/detail'
        query = kvargs
        query['all_tenants'] = True
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack group snapshots: %s' % truncate(res[0]))
        return res[0]['group_snapshots']

    @setup_client
    def get_snapshot(self, group_snapshot_id):
        """Shows details for a volume group snapshot.

        :param group_snapshot_id: The ID of the volume group snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: dict
        """
        path = '/group_snapshots/%s' % group_snapshot_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack group snapshot: %s' % truncate(res[0]))
        return res[0]['group_snapshot']

    @setup_client
    def create_snapshot(self, group_id, name=None, desc=None):
        """Creates a volume group snapshot.

        :param name: The name of the Volume Transfer. [optional]
        :param desc: The description of the Volume Transfer. [optional]
        :param group_id: group id
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:
        """
        data = {
            'group_id': group_id,
        }
        if name is not None:
            data['name'] = name
        if desc is not None:
            data['description'] = desc
        path = '/group_snapshots'
        res = self.client.call(path, 'POST', data={'group_snapshot': data}, token=self.manager.identity.token)
        self.logger.debug('Create openstack group snapshot: %s' % truncate(res[0]))
        return res[0]['group_snapshot']

    @setup_client
    def delete_snapshot(self, group_snapshot_id):
        """Deletes a volume group snapshot.

        :param group_snapshot_id: The ID of the volume group snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        path = '/group_snapshots/%s' % group_snapshot_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack group snapshot: %s' % truncate(res[0]))
        return True

    #
    # Group replication
    #


class OpenstackAttachmentV3(OpenstackVolumeV3Object):
    def __init__(self, volume):
        OpenstackVolumeV3Object.__init__(self, volume.manager)

    @setup_client
    def list(self, detail=True, tenant=None, limit=None, marker=None, all_tenants=True, *args, **kvargs):
        """List attachments with details
        """
        path = '/attachments'
        if detail is True:
            path = '/attachments/detail'

        query = kvargs
        if tenant is not None:
            query['tenant_id'] = tenant
        if limit is not None:
            query['limit'] = limit
        if marker is not None:
            query['marker'] = marker
        if all_tenants is True:
            query['all_tenants'] = 1

        path = '%s?%s' % (path, urlencode(query))

        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack attachments: %s' % truncate(res[0]))
        return res[0]['attachments']

    @setup_client
    def get(self, oid=None, name=None):
        """Get volume attachment

        :param oid: attachment id
        :param name: attachment name
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        if oid is not None:
            path = '/attachments/%s' % oid
        elif name is not None:
            path = '/attachments/detail?name=%s' % name
        else:
            raise OpenstackError('Specify at least attachment id or name')
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack attachment: %s' % truncate(res[0]))
        if oid is not None:
            attachment = res[0]['attachment']
        elif name is not None:
            attachment = res[0]['attachment'][0]

        return attachment


class OpenstackVolume(OpenstackVolumeObject):
    """A volume is a detachable block storage device similar to a USB hard drive. You can attach a volume to one
    instance at a time. The snapshot_id and source_volid parameters specify the ID of the snapshot or volume from which
    this volume originates. If the volume was not created from a snapshot or source volume, these values are null.
    When you create, list, update, or delete volumes, the possible status values are:

    - creating: The volume is being created.
    - available: The volume is ready to attach to an instance.
    - attaching: The volume is attaching to an instance.
    - detaching: The volume is detaching from an instance.
    - in-use: The volume is attached to an instance.
    - maintenance: The volume is locked and being migrated.
    - deleting: The volume is being deleted.
    - awaiting-transfer: The volume is awaiting for transfer.
    - error: A volume creation error occurred.
    - error_deleting: A volume deletion error occurred.
    - backing-up: The volume is being backed up.
    - restoring-backup: A backup is being restored to the volume.
    - error_backing-up: A backup error occurred.
    - error_restoring: A backup restoration error occurred.
    - error_extending: An error occurred while attempting to extend a volume.
    - downloading: The volume is downloading an image.
    - uploading: The volume is being uploaded to an image.
    - retyping: The volume is changing type to another volume type.
    - extending: The volume is being extended.
    """

    def __init__(self, manager):
        OpenstackVolumeObject.__init__(self, manager)

        self.type = OpenstackVolumeType(self)
        self.backup = OpenstackVolumeBackup(self)
        self.snapshot = OpenstackVolumeSnapshot(self)
        self.consistencygroup = OpenstackVolumeConsistencyGroup(self)
        self.qos = OpenstackVolumeQos(self)

    @setup_client
    def list(self, detail=False, tenant=None, limit=None, marker=None, all_tenants=True, *args, **kvargs):
        """List volumes

        :param tenant: tenant id
        :param limit:  Requests a page size of items. Returns a number of items
                       up to a limit value. Use the limit parameter to make an
                       initial limited request and use the ID of the last-seen
                       item from the response as the marker parameter value in
                       a subsequent limited request.
        :param marker: The ID of the last-seen item. Use the limit parameter
                       to make an initial limited request and use the ID of the
                       last-seen item from the response as the marker parameter
                       value in a subsequent limited request.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return a list of dictionaries (each one is a volume):
        [
            {
                "migration_status": null,
                "attachments": [
                    {
                        "server_id": "f4fda93b-06e0-4743-8117-bc8bcecd651b",
                        "attachment_id": "3b4db356-253d-4fab-bfa0-e3626c0b8405",
                        "host_name": null,
                        "volume_id": "6edbc2f4-1507-44f8-ac0d-eed1d2608d38",
                        "device": "/dev/vdb",
                        "id": "6edbc2f4-1507-44f8-ac0d-eed1d2608d38"
                    }
                ],
                "links": [
                    {
                        "href": "http://23.253.248.171:8776/v2/bab7d5c60cd04..",
                        "rel": "self"
                    },
                    {
                        "href": "http://23.253.248.171:8776/bab7d5c60cd041a0..",
                        "rel": "bookmark"
                    }
                ],
                "availability_zone": "nova",
                "os-vol-host-attr:host": "difleming@lvmdriver-1#lvmdriver-1",
                "encrypted": false,
                "os-volume-replication:extended_status": null,
                "replication_status": "disabled",
                "snapshot_id": null,
                "id": "6edbc2f4-1507-44f8-ac0d-eed1d2608d38",
                "size": 2,
                "user_id": "32779452fcd34ae1a53a797ac8a1e064",
                "os-vol-tenant-attr:tenant_id": "bab7d5c60cd041a0a36f7c4b6e1dd978",
                "os-vol-mig-status-attr:migstat": null,
                "metadata": {
                    "readonly": "False",
                    "attached_mode": "rw"
                },
                "status": "in-use",
                "description": null,
                "multiattach": true,
                "os-volume-replication:driver_data": null,
                "source_volid": null,
                "consistencygroup_id": null,
                "os-vol-mig-status-attr:name_id": null,
                "name": "test-volume-attachments",
                "bootable": "false",
                "created_at": "2015-11-29T03:01:44.000000",
                "volume_type": "lvmdriver-1"
            },..
        ]
        """
        path = '/volumes'
        if detail is True:
            path = '/volumes/detail'

        query = kvargs
        if tenant is not None:
            query['tenant_id'] = tenant
        if limit is not None:
            query['limit'] = limit
        if marker is not None:
            query['marker'] = marker
        if all_tenants is True:
            query['all_tenants'] = 1

        path = '%s?%s' % (path, urlencode(query))

        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volumes: %s' % truncate(res[0]))
        return res[0]['volumes']

    @setup_client
    def get(self, oid=None, name=None):
        """
        :param oid: volume id
        :param name: volume name
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        if oid is not None:
            path = '/volumes/%s' % oid
        elif name is not None:
            path = '/volumes/detail?name=%s' % name
        else:
            raise OpenstackError('Specify at least volume id or name')
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volume: %s' % truncate(res[0]))
        if oid is not None:
            volume = res[0]['volume']
        elif name is not None:
            volume = res[0]['volumes'][0]

        return volume

    @setup_client
    def create(self, *args, **kvargs):
        """Creates a volume. To create a bootable volume, include the UUID of the image from which you want to create
        the volume in the imageRef attribute in the request body.

        Preconditions:
            You must have enough volume storage quota remaining to create a volume of size requested.

        Asynchronous Postconditions:
            With correct permissions, you can see the volume status as available through API calls.
            With correct access, you can see the created volume in the storage system that OpenStack Block Storage
            manages.

        Troubleshooting:
            If volume status remains creating or shows another error status, the request failed. Ensure you meet the
            preconditions then investigate the storage back end.
            Volume is not created in the storage system that OpenStack Block Storage manages.
            The storage node needs enough free storage space to match the size of the volume creation request.

        :param size: The size of the volume, in gibibytes (GiB).
        :param description: The volume description.
        :param project_id: The UUID of the tenant in a multi-tenancy cloud.
        :param name: The volume name. [optional]
        :param availability_zone: The availability zone. [optional]
        :param source_volid: The UUID of the source volume. The API creates a new volume with the same size as the
            source volume. [optional]
        :param multiattach: To enable this volume to attach to more than one server, set this value to true. Default
            is false. [optional]
        :param snapshot_id: To create a volume from an existing snapshot, specify the UUID of the volume snapshot. The
            volume is created in same availability zone and with same size as the snapshot. [optional]
        :param imageRef: The UUID of the image from which you want to create the volume. Required to create a bootable
            volume. [optional]
        :param volume_type: The volume type. To create an environment with multiple-storage back ends, you must specify
            a volume type. Block Storage volume back ends are spawned as children to cinder-volume, and they are keyed
            from a unique queue. They are named cinder- volume.HOST.BACKEND. For example,
            cinder-volume.ubuntu.lvmdriver. When a volume is created, the scheduler chooses an appropriate back end to
            handle the request based on the volume type. Default is None. For information about how to use volume types
            to create multiple-storage back ends, see Configure multiple-storage back ends. [optional]
        :param metadata: One or more metadata key and value pairs that are associated with the volume. [optional]
        :param source_replica: The UUID of the primary volume to clone. [optional]
        :param consistencygroup_id: The UUID of the consistency group. [optional]
        :param scheduler_hints: The dictionary of data to send to the scheduler. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created

            {
                "status": "creating",
                "migration_status": null,
                "user_id": "0eea4eabcf184061a3b6db1e0daaf010",
                "attachments": [],
                "links": [
                    {
                        "href": "http://23.253.248.171:8776/v2/bab7d5c..",
                        "rel": "self"
                    },
                    {
                        "href": "http://23.253.248.171:8776/bab7d5c60..",
                        "rel": "bookmark"
                    }
                ],
                "availability_zone": "nova",
                "bootable": "false",
                "encrypted": false,
                "created_at": "2015-11-29T03:01:44.000000",
                "description": null,
                "updated_at": null,
                "volume_type": "lvmdriver-1",
                "name": "test-volume-attachments",
                "replication_status": "disabled",
                "consistencygroup_id": null,
                "source_volid": null,
                "snapshot_id": null,
                "multiattach": false,
                "metadata": {},
                "id": "6edbc2f4-1507-44f8-ac0d-eed1d2608d38",
                "size": 2
            }
        """
        data = kvargs
        path = '/volumes'
        res = self.client.call(path, 'POST', data=jsonDumps({'volume': data}), token=self.manager.identity.token)
        self.logger.debug('Create openstack volume: %s' % truncate(res[0]))
        return res[0]['volume']

    @setup_client
    def update(self, volume_id, *args, **kvargs):
        """Updates a volume.

        :param volume_id: The UUID of the volume.
        :param description: The volume description. [optional]
        :param project_id: The UUID of the project in a multi-tenancy cloud. [optional]
        :param name: The volume name. [optional]
        :param metadata: One or more metadata key and value pairs that are associated with the volume. [optional]
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/volumes/%s' % volume_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'volume': data}), token=self.manager.identity.token)
        self.logger.debug('Update openstack volume: %s' % truncate(res[0]))
        return res[0]['volume']

    @setup_client
    def delete(self, volume_id):
        """Delete a volume.

        :param volume_id: The UUID of the volume.
        :return: None
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/volumes/%s' % volume_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack volume: %s' % truncate(res[0]))
        return res[0]

    @setup_client
    def get_metadata(self, volume_id, key=None):
        """Shows metadata for a volume.

        :param volume_id: The UUID of the volume.
        :return: list of metadata
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/volumes/%s/metadata' % volume_id
        if key is not None:
            path += '/' + key

        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack metadata: %s' % truncate(res[0]))
        return res[0]['metadata']

    @setup_client
    def add_metadata(self, volume_id, metadata):
        """Creates or replaces metadata for a volume. Does not modify items that are not in the request.

        :param volume_id: The UUID of the volume.
        :param metadata: One or more metadata key and value pairs that are associated with the volume.
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/volumes/%s/metadata' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps({'metadata': metadata}),
                               token=self.manager.identity.token)
        self.logger.debug('Add openstack volume %s metadata %s' % (volume_id, metadata))
        return res[0]['metadata']

    @setup_client
    def remove_metadata(self, volume_id, key):
        """Deletes metadata for a volume.

        :param volume_id: The UUID of the volume.
        :param key: The metadata key name for the metadata that you want to remove.
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/volumes/%s/metadata/%s' % (volume_id, key)
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack volume %s metadata key %s' % (volume_id, key))
        return True

    #
    # backend, hosts
    #
    @setup_client
    def get_backend_storage_pools(self, detail=True):
        """Lists all back-end storage pools that are known to the scheduler service.

        :param detail: Indicates whether to show pool details or only pool names in the response. Set to true to show
            pool details. Set to false to show only pool names. Default is false.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            [
                {
                    "name": "pool1",
                    "capabilities": {
                        "updated": "2014-10-28T00:00:00-00:00",
                        "total_capacity_gb": 1024,
                        "free_capacity_gb": 100,
                        "volume_backend_name": "pool1",
                        "reserved_percentage": 0,
                        "driver_version": "1.0.0",
                        "storage_protocol": "iSCSI",
                        "QoS_support": false
                    }
                },..
            ]
        """
        path = '/scheduler-stats/get_pools?detail=%s' % bool2str(detail)
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Show openstack volume backend storage pools %s' % truncate(res[0]))
        return res[0]['pools']

    @setup_client
    def get_backend_capabilities(self, hostname):
        """Shows capabilities for a storage back end on the host. The hostname takes the form of
        hostname@volume_backend_name.

        :param hostname: The name of the host that hosts the storage back end.
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/capabilities/%s' % hostname
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Show openstack volume backend capabilities %s' % truncate(res[0]))
        return res[0]

    @setup_client
    def list_hosts(self):
        """Lists all hosts summary info that is not disabled.

        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            [
                {
                    "service-status": "available",
                    "service": "cinder-backup",
                    "zone": "nova",
                    "service-state": "enabled",
                    "host_name": "node1",
                    "last-update": "2017-03-09T21:38:41.000000"
                },..
            ]
        """
        path = '/os-hosts'
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('List openstack volume hosts summary info %s' % truncate(res[0]))
        return res[0]['hosts']

    #
    # actions
    #
    @setup_client
    def extend(self, volume_id, new_size):
        """Extends the size of a volume to a requested size, in gibibytes (GiB).

        Preconditions:
            Volume status must be available.
            Sufficient amount of storage must exist to extend the volume.
            The user quota must have sufficient volume storage.

        Troubleshooting:

            An error_extending volume status indicates that the request failed. Ensure that you meet the preconditions
            and retry the request. If the request fails again, investigate the storage back end.

        :param volume_id: The UUID of the volume.
        :param new_size: The new size of the volume, in gibibytes (GiB).
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-extend': {
                'new_size': new_size
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Extend openstack volume %s size to %s' % (volume_id, new_size))
        return True

    @setup_client
    def reset_status(self, volume_id, status, attach_status, migration_status):
        """Administrator only. Resets the status, attach status, and migration status for a volume.

        :param volume_id: The UUID of the volume.
        :param status: The volume status.
        :param migration_status: The volume migration status.
        :param attach_status: The volume attach status. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-reset_status': {
                'status': status,
                'attach_status': attach_status,
                'migration_status': migration_status
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Reset openstack volume %s status' % volume_id)
        return True

    @setup_client
    def set_image_metadata(self, volume_id, metadata):
        """Sets the image metadata for a volume.

        :param volume_id: The UUID of the volume.
        :param metadata: One or more metadata key and value pairs for the snapshot, if any.

            "metadata": {
                "image_id": "521752a6-acf6-4b2d-bc7a-119f9148cd8c",
                "image_name": "image",
                "kernel_id": "155d900f-4e14-4e4c-a73d-069cbf4541e6",
                "ramdisk_id": "somedisk"
            }

        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-set_image_metadata': {
                'metadata': metadata
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Set openstack volume %s image metadata' % volume_id)
        return True

    @setup_client
    def remove_image_metadata(self, volume_id, key):
        """Removes image metadata, by key, from a volume.

        :param volume_id: The UUID of the volume.
        :param key: The metadata key name for the metadata that you want to remove.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-unset_image_metadata': {
                'key': key
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Uset openstack volume %s image metadata key' % volume_id)
        return True

    @setup_client
    def show_image_metadata(self, volume_id):
        """Shows image metadata for a volume.

        :param volume_id: The UUID of the volume.
        :param key: The metadata key name for the metadata that you want to remove.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            {
                "metadata": {
                    "key1": "value1",
                    "key2": "value2"
                }
            }
        """
        data = {
            'os-show_image_metadata': {}
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Show openstack volume %s image metadata' % volume_id)
        return res[0].get('metadata', {})

    @setup_client
    def attach_volume_to_server(self, volume_id, server_id, mountpoint):
        """Attaches a volume to a server.

        Preconditions:
            Volume status must be available.
            You should set instance_uuid or host_name.

        :param volume_id: The UUID of the volume.
        :param server_id : The UUID of the attaching instance.
        :param mountpoint: The attaching mount point. Ex: /dev/vdc
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-attach': {
                'instance_uuid': server_id,
                'mountpoint': mountpoint
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Attach openstack volume %s to server' % (volume_id, server_id))
        return True

    @setup_client
    def detach_volume_from_server(self, volume_id, attachment_id, force=False, connector=None):
        """Detaches a volume from a server or forces a volume to detach.
        If force is True Rolls back an unsuccessful detach operation after you disconnect the volume.

        Preconditions:
            Volume status must be in-use.

        :param volume_id: The UUID of the volume.
        :param attachment_id : The interface ID.
        :param force: if True force detach
        :param connector: The connector object.

            "connector": {
                "initiator": "iqn.2012-07.org.fake:01"
            }

        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-detach': {
                'attachment_id': attachment_id
            }
        }
        if force is True:
            data = {
                'os-force_detach': {
                    'attachment_id': attachment_id,
                    'connector': connector
                }
            }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Detach openstack volume %s' % volume_id)
        return True

    @setup_client
    def unmanage(self, volume_id):
        """Removes a volume from Block Storage management without removing the back-end storage object that is
        associated with it.

        Preconditions:
            Volume status must be available.

        :param volume_id: The UUID of the volume.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-unmanage': {}
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Unmanage openstack volume %s' % volume_id)
        return True

    @setup_client
    def migrate(self, volume_id, host, force_host_copy=False, lock_volume=None):
        """Migrates a volume to the specified host. It is generally not recommended to migrate an in-use multiattach
        volume if that volume has more than one active read/write attachment.

        Policy defaults enable only users with the administrative role to perform this operation. Cloud providers can
        change these permissions through the policy.json file.

        Preconditions:
            The volume status must be available or in-use.
            The volume migration_status must be None, deleting, error, or success.
            The volume replication_status must be None, disabled or not-capable.
            The migration must happen to another host from which the volume currently resides.
            The volume must not be a member of a group.
            The volume must not have snapshots.

        Asynchronous Postconditions:
            On success, the volume status will return to its original status of available or in-use and the
            migration_status will be success. On failure, the migration_status will be error. In the case of failure,
            if lock_volume was true and the volume was originally available when it was migrated, the status will go
            back to available.

        :param volume_id: The UUID of the volume.
        :param host: The target host for the volume migration. Host format is host@backend.
        :param force_host_copy: If false (the default), rely on the volume backend driver to perform the migration,
            which might be optimized. If true, or the volume driver fails to migrate the volume itself, a generic
            host-based migration is performed.
        :param lock_volume : If true, migrating an available volume will change its status to maintenance preventing
            other operations from being performed on the volume such as attach, detach, retype, etc. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-migrate_volume': {
                'host': host,
                'force_host_copy': force_host_copy,
            }
        }
        if lock_volume is not None:
            data['os-migrate_volume']['lock_volume'] = lock_volume
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Migrates openstack volume %s' % volume_id)
        return True

    @setup_client
    def force_delete(self, volume_id):
        """Attempts force-delete of volume, regardless of state.

        :param volume_id: The UUID of the volume.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-force_delete': {}
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Force delete openstack volume %s' % volume_id)
        return True

    @setup_client
    def update_bootable_status(self, volume_id):
        """Update the bootable status for a volume, mark it as a bootable volume.

        :param volume_id: The UUID of the volume.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-set_bootable': {
                'bootable': True
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Update bootable status of openstack volume %s' % volume_id)
        return True

    @setup_client
    def change_type(self, volume_id, new_type):
        """Change the volume type of existing volume, Cinder may migrate the volume to proper volume host according
        to the new volume type.
        Retyping an in-use volume from a multiattach-capable type to a non-multiattach-capable type, or vice-versa,
        is not supported. It is generally not recommended to retype an in-use multiattach volume if that volume has
        more than one active read/write attachment.

        :param volume_id: The UUID of the volume.
        :param new_type: The new volume type that volume is changed with.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-retype': {
                'new_type': new_type,
                'migration_policy': 'never'
            }
        }
        path = '/volumes/%s/action' % volume_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Change type of openstack volume %s' % volume_id)
        return True


class OpenstackVolumeType(OpenstackVolumeObject):
    """
    todo: volume type encryption, Private volume type access to project.
    """

    def __init__(self, volume):
        OpenstackVolumeObject.__init__(self, volume.manager)

    @setup_client
    def list(self, *args, **kvargs):
        """Lists volume types.

        :param sort_key: Sorts by an attribute. A valid value is name, status, container_format, disk_format, size, id,
            created_at, or updated_at. Default is created_at. The API uses the natural sorting direction of the sort_key
            attribute value. [optional]
        :param sort_dir: Sorts by one or more sets of attribute and sort direction combinations. If you omit the sort
            direction in a set, default is desc. [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :return a list of dictionaries (each one is a volume type):
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/types'
        query = kvargs
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volume types: %s' % truncate(res[0]))
        return res[0]['volume_types']

    @setup_client
    def get(self, volume_type_id):
        """Shows details for a volume type.

        :param volume_type_id: volume id
        :param name: volume name
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/types/%s' % volume_type_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volume type: %s' % truncate(res[0]))
        return res[0]['volume_type']

    @setup_client
    def create(self, name, desc, is_public=True, extra_spec={}):
        """Creates a volume type. To create an environment with multiple-storage back ends, you must specify a volume
        type. Block Storage volume back ends are spawned as children to cinder-volume, and they are keyed from a unique
        queue. They are named cinder-volume.HOST.BACKEND. For example, cinder-volume.ubuntu.lvmdriver. When a volume is
        created, the scheduler chooses an appropriate back end to handle the request based on the volume type.

        For information about how to use volume types to create multiple- storage back ends, see
        https://docs.openstack.org/cinder/latest/admin/blockstorage-multi-backend.html.

        :param name: The volume type name.
        :param desc: The volume description. [optional]
        :param is_public:
        :param extra_specs:
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = {
            'name': name,
            'description': desc,
            'os-volume-type-access:is_public': True,
            'extra_specs': extra_spec
        }
        path = '/types'
        res = self.client.call(path, 'POST', data=jsonDumps({'volume_type': data}),
                               token=self.manager.identity.token)
        self.logger.debug('Create openstack volume type: %s' % truncate(res[0]))
        return res[0]['volume_type']

    @setup_client
    def update(self, volume_type_id, *args, **kvargs):
        """Updates a volume type.

        :param volume_type_id: The UUID of the volume type.
        :param name: The volume type name.
        :param desc: The volume description. [optional]
        :param is_public:
        :param extra_specs:
        :return: volume dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/volumes/%s' % volume_type_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'volume_type': data}), token=self.manager.identity.token)
        self.logger.debug('Update openstack volume: %s' % truncate(res[0]))
        return res[0]['volume']

    @setup_client
    def delete(self, volume_type_id):
        """Delete a volume type.

        :param volume_type_id: The UUID of the volume type.
        :return: None
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/types/%s' % volume_type_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack volume type: %s' % truncate(res[0]))
        return res[0]


class OpenstackVolumeBackup(OpenstackVolumeObject):
    """A backup is a full copy of a volume stored in an external service. The service can be configured. The only
    supported service is Object Storage. A backup can subsequently be restored from the external service to either the
    same volume that the backup was originally taken from or to a new volume.
    When you create, list, or delete backups, these status values are possible:

    - creating: The backup is being created.
    - available: The backup is ready to restore to a volume.
    - deleting: The backup is being deleted.
    - error: A backup error occurred.
    - restoring: The backup is being restored to a volume.
    - error_restoring: A backup restoration error occurred.

    If an error occurs, you can find more information about the error in the fail_reason field for the backup.
    """
    def __init__(self, volume):
        OpenstackVolumeObject.__init__(self, volume.manager)

    @setup_client
    def list(self, all_tenants=True, detail=False, *args, **kvargs):
        """Lists volume backups.

        :param detail: if True show detail. [default=False]
        :param all_tenants: Shows details for all projects. Admin only. [default=True]
        :param sort_key: Sorts by an attribute. A valid value is name, status, container_format, disk_format, size, id,
            created_at, or updated_at. Default is created_at. The API uses the natural sorting direction of the
            sort_key attribute value. [optional]
        :param sort_dir: Sorts by one or more sets of attribute and sort direction combinations. If you omit the sort
            direction in a set, default is desc. [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request. [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            [
                {
                    "availability_zone": "az1",
                    "container": "volumebackups",
                    "created_at": "2013-04-02T10:35:27.000000",
                    "description": null,
                    "fail_reason": null,
                    "id": "2ef47aee-8844-490c-804d-2a8efe561c65",
                    "links": [
                        {
                            "href": "http://localhost:8776/v2/c95fc3e4afe248a49a28828f286a7b38/backups/2e..",
                            "rel": "self"
                        },
                        {
                            "href": "http://localhost:8776/c95fc3e4afe248a49a28828f286a7b38/backups/2e..",
                            "rel": "bookmark"
                        }
                    ],
                    "name": "backup001",
                    "object_count": 22,
                    "size": 1,
                    "status": "available",
                    "volume_id": "e5185058-943a-4cb4-96d9-72c184c337d6",
                    "is_incremental": true,
                    "has_dependent_backups": false
                },..
            ]
        """
        path = '/backups'
        if detail is True:
            path = '/backups/detail'
        query = kvargs
        query['all_tenants'] = all_tenants
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volume backups: %s' % truncate(res[0]))
        return res[0]['backups']

    @setup_client
    def get(self, backup_id):
        """Shows details for a volume backup.

        :param backup_id: The UUID for a backup.
        :param name: volume name
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            {
                "availability_zone": "az1",
                "container": "volumebackups",
                "created_at": "2013-04-02T10:35:27.000000",
                "description": null,
                "fail_reason": null,
                "id": "2ef47aee-8844-490c-804d-2a8efe561c65",
                "links": [
                    {
                        "href": "http://localhost:8776/v2/c95fc3e4afe248a49a28828f286a7b38/backups/2e...",
                        "rel": "self"
                    },
                    {
                        "href": "http://localhost:8776/c95fc3e4afe248a49a28828f286a7b38/backups/2e...",
                        "rel": "bookmark"
                    }
                ],
                "name": "backup001",
                "object_count": 22,
                "size": 1,
                "status": "available",
                "volume_id": "e5185058-943a-4cb4-96d9-72c184c337d6",
                "is_incremental": true,
                "has_dependent_backups": false
            }
        """
        path = '/backups/%s' % backup_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volume backup: %s' % truncate(res[0]))
        return res[0]['backup']

    @setup_client
    def create(self, name, volume_id, desc=None, container=None, force=False, incremental=False, snapshot_id=None):
        """Creates a Block Storage backup from a volume.
        The status of the volume must be available or if the force flag is used, backups of in-use volumes may also be
        created.

        :param container: The container name or null. [optional]
        :param desc: The backup description or null. [optional]
        :param incremental: The backup mode. A valid value is true for incremental backup mode or false for full backup
            mode. Default is false. [optional]
        :param volume_id: The UUID of the volume.
        :param force: Indicates whether to backup, even if the volume is attached. Default is false. [optional]
        :param name: The backup name.
        :param snapshot_id: The UUID of the source volume snapshot. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = {
            'name': name,
            'description': desc,
            'volume_id': volume_id,
            'container': container,
            'force': force,
            'incremental': incremental,
            'snapshot_id': snapshot_id
        }
        path = '/backups'
        res = self.client.call(path, 'POST', data=jsonDumps({'backup': data}),
                               token=self.manager.identity.token)
        self.logger.debug('Create openstack volume backup: %s' % truncate(res[0]))
        return res[0]['backup']

    @setup_client
    def restore(self, backup_id, name=None, volume_id=None):
        """Restores a Block Storage backup to an existing or new Block Storage volume. You must specify either the UUID
        or name of the volume. If you specify both the UUID and name, the UUID takes priority.
        If specifying volume_id the status of the volume must be available.

        :param backup_id: The UUID for a backup.
        :param name: The volume type name.
        :param volume_id: The UUID of the volume.
        :return:

            {
                "restore": {
                    "backup_id": "2ef47aee-8844-490c-804d-2a8efe561c65",
                    "volume_id": "795114e8-7489-40be-a978-83797f2c1dd3"
                }
            }

        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        if name is not None:
            data = {'name': name}
        elif volume_id is not None:
            data = {'volume_id': volume_id}
        path = '/backups/%s/restore' % backup_id
        res = self.client.call(path, 'POST', data=jsonDumps({'restore': data}), token=self.manager.identity.token)
        self.logger.debug('Restore openstack backup: %s' % truncate(res[0]))
        return res[0]['restore']

    @setup_client
    def delete(self, backup_id):
        """Delete a volume backup.

        :param backup_id: The UUID for a backup.
        :return: None
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/backups/%s' % backup_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack volume backup: %s' % truncate(res[0]))
        return res[0]

    @setup_client
    def export_record(self, backup_id):
        """Export information about a backup.

        :param backup_id: The UUID for a backup.
        :return:

            {
                "backup-record": {
                    "backup_service": "cinder.backup.drivers.swift",
                    "backup_url": "eyJzdGF0"
                }
            }

        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/backups/%s' % backup_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Export openstack volume backup: %s' % truncate(res[0]))
        return res[0]['backup-record']

    @setup_client
    def import_record(self, backup_id, backup_service, backup_url):
        """Import information about a backup.

        :param backup_id: The UUID for a backup.
        :param backup_service: The service used to perform the backup.
        :param backup_url: An identifier string to locate the backup.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            {
                "backup-record": {
                    "backup_service": "cinder.backup.drivers.swift",
                    "backup_url": "eyJzdGF0"
                }
            }
        """
        data = {
            'backup_service': backup_service,
            'backup_url': backup_url
        }
        path = '/backups/%s' % backup_id
        res = self.client.call(path, 'POST', data=jsonDumps({'backup-record': data}),
                               token=self.manager.identity.token)
        self.logger.debug('Import openstack volume backup: %s' % truncate(res[0]))
        return res[0]['backup']

    @setup_client
    def force_delete(self, backup_id):
        """Force-deletes a backup. Specify the os-force_delete action in the request body. This operation deletes the
        backup and any backup data.
        The backup driver returns the 405 status code if it does not support this operation.

        :param backup_id: The UUID for a backup.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:
        """
        data = {
            'os-force_delete': {}
        }
        path = '/backups/%s/action' % backup_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Force openstack volume backup delete: %s' % truncate(res[0]))
        return True

    @setup_client
    def reset_status(self, backup_id, status):
        """Reset a backup's status.

        :param backup_id: The UUID for a backup.
        :param status: The status for the backup.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:
        """
        data = {
            'os-reset_status': {
                'status': status
            }
        }
        path = '/backups/%s/action' % backup_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Reset openstack volume backup status: %s' % truncate(res[0]))
        return True


class OpenstackVolumeSnapshot(OpenstackVolumeObject):
    """A snapshot is a point-in-time copy of the data that a volume contains.
    When you create, list, or delete snapshots, these status values are possible:

    - creating: The snapshot is being created.
    - available: The snapshot is ready to use.
    - backing-up: The snapshot is being backed up.
    - deleting: The snapshot is being deleted.
    - error: A snapshot creation error occurred.
    - deleted: The snapshot has been deleted.
    - unmanaging: The snapshot is being unmanaged.
    - restoring: The snapshot is being restored to a volume.
    - error_deleting: A snapshot deletion error occurred.
    """

    def __init__(self, volume):
        OpenstackVolumeObject.__init__(self, volume.manager)

    @setup_client
    def list(self, *args, **kvargs):
        """Lists all Block Storage snapshots, with details, that the project can access.

        :param detail: if True show details
        :param volume_id: uuid of the volume
        :param sort_key: Sorts by an attribute. A valid value is name, status, container_format, disk_format, size, id,
            created_at, or updated_at. Default is created_at. The API uses the natural sorting direction of the sort_key
            attribute value. [optional]
        :param sort_dir: Sorts by one or more sets of attribute and sort direction combinations. If you omit the sort
            direction in a set, default is desc. [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            [
                {
                    "status": "available",
                    "metadata": {
                        "name": "test"
                    },
                    "os-extended-snapshot-attributes:progress": "100%",
                    "name": "test-volume-snapshot",
                    "volume_id": "173f7b48-c4c1-4e70-9acc-086b39073506",
                    "os-extended-snapshot-attributes:project_id": "bab7d5c60cd041a0a36f7c4b6e1dd978",
                    "created_at": "2015-11-29T02:25:51.000000",
                    "size": 1,
                    "id": "b1323cda-8e4b-41c1-afc5-2fc791809c8c",
                    "description": "volume snapshot",
                    "updated_at": "2015-12-11T07:24:57Z"
                },..
            ]
        """
        path = '/snapshots/detail'
        query = kvargs
        query['all_tenants'] = True
        volume_id = query.pop('volume_id', None)
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        res = res[0]['snapshots']
        resp = []
        if volume_id is not None:
            resp = [s for s in res if s.get('volume_id') == volume_id]
        else:
            resp = res
        self.logger.debug('Get openstack snapshots: %s' % truncate(resp))
        return resp

    @setup_client
    def get(self, snapshot_id):
        """Shows details for a snapshot.

        :param snapshot_id: snapshot id
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            {
                "status": "available",
                "os-extended-snapshot-attributes:progress": "100%",
                "description": "Daily backup",
                "created_at": "2013-02-25T04:13:17.000000",
                "metadata": {},
                "volume_id": "5aa119a8-d25b-45a7-8d1b-88e127885635",
                "os-extended-snapshot-attributes:project_id": "0c2eba2c5af04d3f9e9d0d410b371fde",
                "size": 1,
                "id": "2bb856e1-b3d8-4432-a858-09e4ce939389",
                "name": "snap-001",
                "updated_at": "2013-03-11T07:24:57Z"
            }
        """
        path = '/snapshots/%s' % snapshot_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack snapshot: %s' % truncate(res[0]))
        return res[0]['snapshot']

    @setup_client
    def create(self, name, force=False, *args, **kvargs):
        """Creates a volume snapshot, which is a point-in-time, complete copy of a volume. You can create a volume from
        a snapshot.

        :param name: The snapshot name.
        :param description: The snapshot description.
        :param volume_id: The UUID of the volume.
        :param force: Indicates whether to snapshot, even if the volume is attached. [default=False]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = kvargs
        data['name'] = name
        data['force'] = force
        path = '/snapshots'
        res = self.client.call(path, 'POST', data=jsonDumps({'snapshot': data}), token=self.manager.identity.token)
        self.logger.debug('Create openstack snapshot: %s' % truncate(res[0]))
        return res[0]['snapshot']

    @setup_client
    def update(self, snapshot_id, *args, **kvargs):
        """Updates a snapshot.

        :param name: The name of the Volume Transfer.
        :param description: The snapshot description. [optional]
        :return: snapshot dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/snapshots/%s/update' % snapshot_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'snapshot': data}),
                               token=self.manager.identity.token)
        self.logger.debug('Update openstack snapshot: %s' % truncate(res[0]))
        return res[0]['snapshot']

    @setup_client
    def delete(self, snapshot_id):
        """Delete a snapshot.

        :param snapshot_id: The UUID of the snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        path = '/snapshots/%s' % snapshot_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack snapshot: %s' % truncate(res[0]))
        return True

    #
    # action
    #
    @setup_client
    def reset_status(self, snapshot_id, status):
        """Resets the status.

        :param snapshot_id: The snapshots name.
        :param status:The status for the snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'os-reset_status': {
                'status': status
            }
        }
        path = '/snapshots/%s/action' % snapshot_id
        res = self.client.call(path, 'POST', data=jsonDumps({'snapshot': data}), token=self.manager.identity.token)
        self.logger.debug('Reset openstack snapshot status: %s' % truncate(res[0]))
        return True

    @setup_client
    def revert_to(self, volume_id, snapshot_id):
        """Revert volume to snapshot

        :param volume_id: The snapshots name.
        :param snapshot_id: The snapshots name.
        :param status:The status for the snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        data = {
            'revert': {
                'snapshot_id': snapshot_id
            }
        }
        path = '/volumes/%s/action' % volume_id
        self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Revert openstack volume %s to snapshot %s' % (volume_id, snapshot_id))
        return True

    #
    # metadata
    #
    @setup_client
    def get_metadata(self, snapshot_id):
        """Shows metadata for a snapshot.

        :param snapshot_id: The UUID of the snapshot.
        :return: list of metadata
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/snapshots/%s/metadata' % snapshot_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack volume snapshot metadata: %s' % truncate(res[0]))
        return res[0]['metadata']

    @setup_client
    def add_metadata(self, snapshot_id, metadata):
        """Updates metadata for a snapshot. Creates or replaces metadata items that match keys. Does not modify items
        that are not in the request.

        :param snapshot_id: The UUID of the snapshot.
        :param metadata: One or more metadata key and value pairs that are associated with the volume snapshot.
        :return: list of metadata
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/snapshots/%s/metadata' % snapshot_id
        res = self.client.call(path, 'POST', data=jsonDumps({'metadata': metadata}),
                               token=self.manager.identity.token)
        self.logger.debug('Add openstack volume snapshot %s metadata %s' % truncate(res[0]))
        return res[0]['metadata']

    @setup_client
    def remove_metadata(self, snapshot_id, metadata):
        """Replaces all the snapshot's metadata with the key-value pairs in the request.

        :param snapshot_id: The UUID of the snapshot.
        :param metadata: One or more metadata key and value pairs for the snapshot, if any.
        :return: True
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/snapshots/%s/metadata' % snapshot_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'metadata': metadata}),
                               token=self.manager.identity.token)
        self.logger.debug('Update openstack volume snapshot %s metadata %s' % truncate(res[0]))
        return True


class OpenstackVolumeConsistencyGroup(OpenstackVolumeObject):
    """Consistency groups enable you to create snapshots at the exact same point in time from multiple volumes. For
    example, a database might place its tables, logs, and configuration on separate volumes. To restore this database
    from a previous point in time, it makes sense to restore the logs, tables, and configuration together from the
    exact same point in time.
    """
    def __init__(self, volume):
        OpenstackVolumeObject.__init__(self, volume.manager)

    @setup_client
    def list(self, *args, **kvargs):
        """Lists consistency groups.

        :param detail: if True show details
        :param sort_key: Sorts by an attribute. A valid value is name, status, container_format, disk_format, size, id,
            created_at, or updated_at. Default is created_at. The API uses the natural sorting direction of the sort_key
            attribute value. [optional]
        :param sort_dir: Sorts by one or more sets of attribute and sort direction combinations. If you omit the sort
            direction in a set, default is desc. [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            [
                {
                    "id": "6f519a48-3183-46cf-a32f-41815f813986",
                    "name": "my-cg1"
                },..
            ]

            or

            [
                {
                    "id": "6f519a48-3183-46cf-a32f-41815f813986",
                    "status": "available",
                    "availability_zone": "az1",
                    "created_at": "2015-09-16T09:28:52.000000",
                    "name": "my-cg1",
                    "description": "my first consistency group",
                    "volume_types": [
                        "123456"
                    ]
                },..
            ]
        """
        path = '/consistencygroups'
        if kvargs.pop('detail', False) is True:
            path = '/consistencygroups/detail'
        query = kvargs
        query['all_tenants'] = True
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack consistencygroups: %s' % truncate(res[0]))
        return res[0]['consistencygroups']

    @setup_client
    def get(self, consistencygroup_id):
        """Shows details for a consistencygroup.

        :param consistencygroup_id: consistencygroup id
        :param name: qos-spec name
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            {
                "id": "6f519a48-3183-46cf-a32f-41815f813986",
                "status": "available",
                "availability_zone": "az1",
                "created_at": "2015-09-16T09:28:52.000000",
                "name": "my-cg1",
                "description": "my first consistency group",
                "volume_types": [
                    "123456"
                ]
            }
        """
        path = '/consistencygroups/%s' % consistencygroup_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack consistencygroup: %s' % truncate(res[0]))
        return res[0]['consistencygroup']

    @setup_client
    def create(self, name, *args, **kvargs):
        """Creates a consistency group.

        :param name: The consistencygroups name.
        :param description: The consistency group description.
        :param availability_zone: The name of the availability zone. [optional]
        :param volume_types: The list of volume types separated by commas. In an environment with multiple-storage
            back ends, the scheduler determines where to send the volume based on the volume type.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = kvargs
        data['name'] = name
        path = '/consistencygroups'
        res = self.client.call(path, 'POST', data=jsonDumps({'consistencygroup': data}), token=self.manager.identity.token)
        self.logger.debug('Create openstack consistencygroup: %s' % truncate(res[0]))
        return res[0]['consistencygroup']

    @setup_client
    def create_from_source(self, name, *args, **kvargs):
        """Creates a consistency group from source.

        :param name: The name of the Volume Transfer.
        :param description: The consistency group description. [optional]
        :param project_id: The UUID of the project in a multi-tenancy cloud.
        :param source_cgid: The UUID of the source consistency group. [optional]
        :param cgsnapshot_id: The UUID of the consistency group snapshot. [optional]
        :param user_id: The UUID of the user.
        :param status: The status of the consistency group.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = kvargs
        data['name'] = name
        path = '/consistencygroups'
        res = self.client.call(path, 'POST', data=jsonDumps({'consistencygroup': data}), token=self.manager.identity.token)
        self.logger.debug('Create openstack consistencygroup: %s' % truncate(res[0]))
        return res[0]['consistencygroup']

    @setup_client
    def update(self, consistencygroup_id, *args, **kvargs):
        """Updates a qos-spec.

        :param name: The name of the Volume Transfer.
        :param description: The consistency group description. [optional]
        :param remove_volumes: One or more volume UUIDs, separated by commas, to remove from the volume consistency
            group. [optional]
        :param add_volumes: One or more volume UUIDs, separated by commas, to add to the volume consistency group.
            [optional]
        :return: qos-spec dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/consistencygroups/%s/update' % consistencygroup_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'consistencygroup': data}),
                               token=self.manager.identity.token)
        self.logger.debug('Update openstack consistencygroup: %s' % truncate(res[0]))
        return res[0]['qos-spec']

    @setup_client
    def delete(self, consistencygroup_id, force=False):
        """Delete a consistency group.

        :param consistencygroup_id: The UUID of the consistency group.
        :param force: Indicates whether to backup, even if the volume is attached. [default=False]
        :param availability_zone: The name of the availability zone. [optional]
        :param volume_types: The list of volume types separated by commas. In an environment with multiple-storage
            back ends, the scheduler determines where to send the volume based on the volume type.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = {
            'consistencygroup': {
                'force': force
            }
        }
        path = '/consistencygroups/%s' % consistencygroup_id
        res = self.client.call(path, 'POST', data=jsonDumps(data), token=self.manager.identity.token)
        self.logger.debug('Delete openstack consistencygroup: %s' % truncate(res[0]))
        return True

    #
    # snapshot
    #
    @setup_client
    def list_snapshots(self, *args, **kvargs):
        """Lists all consistency group snapshots.

        :param detail: if True show details
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            [
                {
                    "id": "6f519a48-3183-46cf-a32f-41815f813986",
                    "name": "my-cg1"
                },,..
            ]

            or

            [
                {
                    "id": "aed36625-a6d7-4681-ba59-c7ba3d18c148",
                    "consistencygroup_id": "aed36625-a6d7-4681-ba59-c7ba3d18dddd",
                    "status": "error",
                    "created_at": "2015-09-16T09:31:15.000000",
                    "name": "my-cg2",
                    "description": "Edited description"
                },..
            ]
        """
        path = '/cgsnapshots'
        if kvargs.pop('detail', False) is True:
            path = '/cgsnapshots/detail'
        query = kvargs
        query['all_tenants'] = True
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack consistencygroup snapshots: %s' % truncate(res[0]))
        return res[0]['cgsnapshots']

    @setup_client
    def get_snapshot(self, cgsnapshot_id):
        """Shows details for a consistency group snapshot.

        :param cgsnapshot_id: The ID of the consistency group snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:

            {
                "id": "6f519a48-3183-46cf-a32f-41815f813986",
                "consistencygroup_id": "6f519a48-3183-46cf-a32f-41815f814444",
                "status": "available",
                "created_at": "2015-09-16T09:28:52.000000",
                "name": "my-cg1",
                "description": "my first consistency group"
            }
        """
        path = '/cgsnapshots/%s' % cgsnapshot_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack consistencygroup snapshot: %s' % truncate(res[0]))
        return res[0]['cgsnapshot']

    @setup_client
    def create_snapshot(self, cgsnapshot_id):
        """Creates a consistency group snapshot.

        :param name: The name of the Volume Transfer.
        :param description: The description of the Volume Transfer.
        :param consistencygroup_id: consistencygroup id
        :param user_id:
        :param project_id:
        :param status:
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return:
        """
        path = '/cgsnapshots/%s' % cgsnapshot_id
        res = self.client.call(path, 'POST', data='', token=self.manager.identity.token)
        self.logger.debug('Create openstack consistencygroup snapshot: %s' % truncate(res[0]))
        return res[0]['cgsnapshot']

    @setup_client
    def delete_snapshot(self, cgsnapshot_id):
        """Deletes a consistency group snapshot.

        :param cgsnapshot_id: The ID of the consistency group snapshot.
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return: True
        """
        path = '/cgsnapshots/%s' % cgsnapshot_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack consistencygroup snapshot: %s' % truncate(res[0]))
        return True


class OpenstackVolumeQos(OpenstackVolumeObject):
    """
    todo: manage association
    """

    def __init__(self, volume):
        OpenstackVolumeObject.__init__(self, volume.manager)

    @setup_client
    def list(self, *args, **kvargs):
        """Lists quality of service (QoS) specifications.

        :param sort_key: Sorts by an attribute. A valid value is name, status, container_format, disk_format, size, id,
            created_at, or updated_at. Default is created_at. The API uses the natural sorting direction of the sort_key
            attribute value. [optional]
        :param sort_dir: Sorts by one or more sets of attribute and sort direction combinations. If you omit the sort
            direction in a set, default is desc. [optional]
        :param limit: Requests a page size of items. Returns a number of items up to a limit value. Use the limit
            parameter to make an initial limited request and use the ID of the last-seen item from the response as the
            marker parameter value in a subsequent limited request. [optional]
        :param offset: Used in conjunction with limit to return a slice of items. offset is where to start in the list.
            [optional]
        :param marker: The ID of the last-seen item. Use the limit parameter to make an initial limited request and use
            the ID of the last-seen item from the response as the marker parameter value in a subsequent limited
            request. [optional]
        :return a list of dictionaries (each one is a qos-specs):
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/qos-specs'
        query = kvargs
        path = '%s?%s' % (path, urlencode(query))
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack qos specs: %s' % truncate(res[0]))
        return res[0]['qos-specs']

    @setup_client
    def get(self, qos_spec_id):
        """Shows details for a QoS specification.

        :param qos_spec_id: qos spec id
        :param name: qos-spec name
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/qos-specs/%s' % qos_spec_id
        res = self.client.call(path, 'GET', data='', token=self.manager.identity.token)
        self.logger.debug('Get openstack qos spec: %s' % truncate(res[0]))
        return res[0]['qos_spec']

    @setup_client
    def create(self, name, *args, **kvargs):
        """Creates a QoS specification.

        :param name: The qos-specs name.
        :param consumer : The consumer type. [optional]
        :param availability: [optional]
        :param numberOfFailures: [optional]
        :raises OpenstackError: raise :class:`.OpenstackError`
        :return dictionary with the resource created
        """
        data = kvargs
        data['name'] = name
        path = '/qos-specs'
        res = self.client.call(path, 'POST', data=jsonDumps({'qos-specs': data}), token=self.manager.identity.token)
        self.logger.debug('Create openstack qos spec: %s' % truncate(res[0]))
        return res[0]['qos-spec']

    @setup_client
    def update(self, qos_spec_id, *args, **kvargs):
        """Updates a qos-spec.

        :param qos_spec_id: qos spec id
        :param name: The qos-specs name.
        :return: qos-spec dict object
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        data = kvargs
        path = '/qos-specs/%s' % qos_spec_id
        res = self.client.call(path, 'PUT', data=jsonDumps({'qos-speca': data}), token=self.manager.identity.token)
        self.logger.debug('Update openstack qos spec: %s' % truncate(res[0]))
        return res[0]['qos-spec']

    @setup_client
    def delete(self, qos_spec_id):
        """Deletes a QoS specification.

        :param qos_spec_id: qos spec id
        :return: None
        :raises OpenstackError: raise :class:`.OpenstackError`
        """
        path = '/qos-specs/%s' % qos_spec_id
        res = self.client.call(path, 'DELETE', data='', token=self.manager.identity.token)
        self.logger.debug('Delete openstack qos spec: %s' % truncate(res[0]))
        return res[0]
